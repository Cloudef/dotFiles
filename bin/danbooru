#!/bin/sh
# Crawl danbooru for pictures
#
# Uses JSON API instead of crawling HTML
# Much fool proof and allows more control.
# Also it won't bloat your directory with lots of images,
# that slows down various file browsers.


# Local directory where to store the pictures
# Images are stored in following format
#
# $LOCAL_STORE/$RATING/$ARTIST/$IMAGE
#
# eg.
# /Danbooru/Safe/Rib:y(uhki)/12401290395023.jpg"
LOCAL_STORE="$HOME/Kuvat/Danbooru"

# Artist database
# Since danbooru API allows no easy way to get artist from post,
# it needs to be crawled, and this is _really_ slow.
#
# We can workaround it by keeping local artist cache, which will speed up things eventually.
ARTIST_DB="$LOCAL_STORE/artist.db"

# Status to download
# active  = Only download active posts
# pending = Download pending && active
DANBOORU_STATUS="pending"

# Rating to download
# s = Only download safe posts
# q = Download questionable && safe posts
# e = Download explicit && questionable && safe posts
DANBOORU_RATING="e"

# Download pictures with no artist tag?
DANBOORU_NO_ARTIST=0

# Limit the number of sub processes for download
FORK_LIMIT=40

# Lock file
LOCK_FILE="/tmp/danbooru.lck"

# Danbooru API root
DANBOORU_ROOT="http://danbooru.donmai.us"

# Depencies for this script
BIN_DEPS="curl jsawk awk"

error()
{
   echo -e "$@"
   exit 1
}

check_deps()
{
   for i in $BIN_DEPS; do
      which $i > /dev/null
      if [ $? -ne 0 ]; then
         error "Missing depency: $i"
      fi
   done
}

sigint()
{
   # Kill all sub processes
   test -z "`jobs -p`" || kill -9 `jobs -p` &> /dev/null

   # Unlock
   unlock

   echo "$(basename "$0"): SIGINT"
   exit 0
}

# Lock
lock()
{
   [[ ! -f "$LOCK_FILE" ]] || error "$(basename "$0") is already running!"
   touch "$LOCK_FILE"
}

# Unlock
unlock()
{
   [[ -f "$LOCK_FILE" ]] || return
   rm "$LOCK_FILE"
}

# Usage
usage()
{
   for i in $@
   do
      [[ "$i" != "-h" ]] && [[ "$i" != "--help" ]] || error "$(basename "$0") [page] [tags] [limit]"
   done
}

# $1 = API URL
# $2 = URL Arguments
get_json()
{
   curl -s "$DANBOORU_ROOT/$1.json?$2"
}

# $1 = JSON data
# $2 = Element
# Parses quoted strings (Needs eval set -- ${ARRAY[@]})
json_parse_q()
{
   echo "$1" | jsawk "return this.$2" | sed -e 's/\[\"/"/' -e 's/\"\]/"/' -e 's/","/" "/g'
}

# $1 = JSON data
# $2 = Element
# Parses unquoted strings
json_parse()
{
   echo "$1" | jsawk "return this.$2" | sed -e 's/\[\"//' -e 's/\"\]//' -e 's/","/ /g'
}

# $1 = JSON rating
# Return readable rating
rating_str()
{
   [[ "$@" != "s" ]] || echo "Safe"
   [[ "$@" != "q" ]] || echo "Questionable"
   [[ "$@" != "m" ]] || echo "Explicit"
}

# $1 = Matching tag
# $2 = Artist name
# Caches artist to DB file
cache_artist()
{
   echo -e "$1::$2" >> "$ARTIST_DB"
}

# $1 = Matching tag
# Return artist, if matching tag is found from cache
check_cache()
{
   local MATCH=

   [[ -f "$ARTIST_DB" ]] || return

   for TAG in $(cat "$ARTIST_DB")
   do
      if [[ "$(echo -e "$TAG" | awk -F'::' '{print $1}')" == "$1" ]]
      then
         MATCH="$TAG"
         break
      fi
   done

   # Echo name
   echo -e "$MATCH" | awk -F'::' '{print $2}'
}

# $1 = URL
# $2 = Rating
# $3 = Tags
# Stores the picture
store_picture()
{
   local RESULT=
   local ARTIST=
   local MATCH=

   if [ -d "$LOCAL_STORE/$2" ]
   then
      [[ ! "$(find "$LOCAL_STORE/$2" -type f -name "$(basename $1)" | sed 1q)" ]] || echo "exist: $(basename $1)" && return
   fi

   # Check cache first
   for TAG in $3
   do
      ARTIST="$(check_cache "$TAG")"
      if [[ "$ARTIST" ]]
      then
         MATCH="$TAG"
         break
      fi
   done

   # If no match in cache, get from danbooru
   if [[ ! "$MATCH" ]]
   then
      for TAG in $3
      do
         RESULT="$(get_json "artist/index" "limit=1&name=$TAG")"
         if [[ "$RESULT" != "[]" ]]
         then
            MATCH="$TAG"
            break
         fi
      done

      if [[ "$MATCH" ]]
      then
         ARTIST="$(json_parse "$RESULT" 'name')"
         cache_artist "$MATCH" "$ARTIST"
      else
         [[ $DANBOORU_NO_ARTIST -eq 0 ]] || return
         ARTIST="unknown"
      fi
   fi

   # mkdirs
   mkdir -p "$LOCAL_STORE/$2"
   mkdir -p "$LOCAL_STORE/$2/$ARTIST"

   # download
   echo -e "$LOCAL_STORE/$2/$ARTIST/$(basename "$1")"
   curl -s -o "$LOCAL_STORE/$2/$ARTIST/$(basename "$1")" "$1"
}

# Main
main()
{
   local RESULT=
   local URLS=
   local RATING=
   local STATUS=
   local TAGS=

   local LIMIT="${3-100}"
   local PAGE="${1-1}"
   local i=

   # Trap SIGINT
   trap sigint SIGINT

   RESULT="$(get_json "post/index" "page=$PAGE&limit=$LIMIT&tags=$2")"
   URLS=("$(json_parse "$RESULT" 'file_url')")
   TAGS=("$(json_parse_q "$RESULT" 'tags')")
   RATING=($(json_parse "$RESULT" 'rating'))
   STATUS=($(json_parse "$RESULT" 'status'))

   # Unfortunately we need to do this for tags
   eval set -- ${TAGS[@]}

   i=0
   for URL in $URLS
   do
      # Check status
      [[ "${STATUS[$i]}" == "pending" ]] && [[ "$DANBOORU_STATUS" == "pending" ]] || \
      [[ "${STATUS[$i]}" == "active" ]]                                           || continue

      # Check rating
      [[ "${RATING[$i]}" == "e" ]] && [[ "$DANBOORU_RATING" == "e" ]]                                    || \
      [[ "${RATING[$i]}" == "q" ]] && [[ "$DANBOORU_RATING" == "q" ]] || [[ "$DANBOORU_RATING" == "e" ]] || \
      [[ "${RATING[$i]}" == "s" ]]                                                                       || continue

      if [ $(jobs -p | wc -l) -lt $FORK_LIMIT ]
      then
         store_picture "$URL" "$(rating_str "${RATING[$i]}")" "$1" &
      else
         store_picture "$URL" "$(rating_str "${RATING[$i]}")" "$1"
      fi

      ((i++)) # Next array index
      shift 1 # Next tag cloud
   done
}

check_deps
usage $@
lock
main $@
unlock
